<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VaultChain — Browser Multi-chain Wallet (Prototype)</title>

  <!-- Tailwind for quick UI -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- UMD/browser builds -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.6.4/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.95.3/dist/web3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bip39@3.0.4/browser.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ed25519-hd-key@1.2.0/dist/index.umd.js"></script>

  <style>
    body { background: linear-gradient(135deg,#0f172a,#111827 60%); color: #e6eef8; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    .card { background: rgba(255,255,255,0.04); border-radius: 12px; padding: 16px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace; }
    a { color: #93c5fd; }
  </style>
</head>
<body class="min-h-screen flex items-start justify-center py-8 px-4">
  <div class="w-full max-w-3xl space-y-6">
    <header class="flex items-center justify-between">
      <div>
        <h1 class="text-2xl font-bold">VaultChain — Multi-chain Wallet (Prototype)</h1>
        <div class="text-xs text-slate-300 mt-1">EVM + Solana — browser-only prototype</div>
      </div>
      <div class="text-xs text-slate-400">Prototype • Use carefully</div>
    </header>

    <main class="card space-y-4">
      <div class="flex gap-2 flex-wrap">
        <button id="createBtn" class="px-3 py-2 bg-emerald-600 rounded">Create Wallet</button>
        <button id="importMnemonicBtn" class="px-3 py-2 bg-yellow-600 rounded">Import Mnemonic</button>
        <button id="importKeyBtn" class="px-3 py-2 bg-sky-600 rounded">Import Private Key</button>
        <button id="logoutBtn" class="px-3 py-2 bg-red-600 rounded">Logout / Clear</button>
      </div>

      <div class="grid md:grid-cols-2 gap-6">
        <section>
          <h2 class="font-semibold mb-2">Chains</h2>
          <div id="chains" class="flex gap-2 flex-wrap">
            <!-- Buttons injected by script -->
          </div>

          <div class="mt-4">
            <div class="text-sm text-slate-300">Loaded wallet</div>
            <div id="loaded" class="mt-2 text-sm mono">No wallet loaded</div>
            <div class="flex gap-2 mt-3">
              <button id="copyAddrBtn" class="px-3 py-1 bg-slate-700 rounded">Copy Address</button>
              <button id="showMnemonicBtn" class="px-3 py-1 bg-slate-700 rounded">Show Mnemonic</button>
            </div>
          </div>
        </section>

        <section>
          <h2 class="font-semibold mb-2">Receive / Send</h2>

          <div>
            <div class="text-xs text-slate-300">Receive address</div>
            <div id="receiveAddr" class="mt-1 mono p-2 bg-white/5 rounded break-words">—</div>
            <div class="flex gap-2 mt-2">
              <button id="copyRecBtn" class="px-3 py-1 bg-indigo-600 rounded">Copy</button>
              <button id="requestBtn" class="px-3 py-1 bg-emerald-600 rounded">Request (dev only)</button>
            </div>
          </div>

          <div class="mt-4">
            <div class="text-xs text-slate-300">Send</div>
            <input id="toInput" placeholder="Recipient address" class="w-full mt-2 p-2 rounded bg-white/5 mono"/>
            <input id="amountInput" placeholder="Amount (example: 0.01)" class="w-full mt-2 p-2 rounded bg-white/5 mono"/>
            <div class="flex gap-2 mt-2">
              <button id="sendBtn" class="px-3 py-1 bg-amber-500 rounded">Send</button>
              <button id="clearSendBtn" class="px-3 py-1 bg-slate-700 rounded">Clear</button>
            </div>
            <div id="sendNotice" class="text-xs mt-2 text-slate-300"></div>
          </div>
        </section>
      </div>

      <section>
        <h3 class="font-semibold mb-2">Balances & History</h3>
        <div class="grid md:grid-cols-2 gap-4">
          <div>
            <div class="text-xs text-slate-300">Balance</div>
            <div id="balance" class="mono mt-1 p-2 bg-white/5 rounded">—</div>
            <div class="text-xs mt-2 text-slate-400">EVM balances via public RPC; Solana via mainnet RPC</div>
          </div>
          <div>
            <div class="text-xs text-slate-300">Solana History (last ~10)</div>
            <div id="solHistory" class="mt-1 space-y-2 text-xs"></div>
            <div class="text-xs mt-2 text-slate-400">EVM history requires a scanner API (Etherscan/Covalent/Alchemy). See notes.</div>
          </div>
        </div>
      </section>

      <section class="text-xs text-slate-400">
        <strong>Notes:</strong>
        <ul class="list-disc ml-5">
          <li>This is a prototype — do NOT use large amounts of real funds unless you know what you’re doing.</li>
          <li>For production: encrypt the mnemonic, use secure vaults, and paid RPC + indexers for reliability.</li>
        </ul>
      </section>
    </main>
  </div>

  <script>
  (function(){
    // ---------- Configuration ----------
    const CHAINS = {
      ETH: { id: 'ETH', name: 'Ethereum', rpc: 'https://rpc.ankr.com/eth', symbol: 'ETH', explorer: 'https://etherscan.io/tx/' },
      BSC: { id: 'BSC', name: 'BNB Smart Chain', rpc: 'https://bsc-dataseed.binance.org/', symbol: 'BNB', explorer: 'https://bscscan.com/tx/' },
      AVAX: { id: 'AVAX', name: 'Avalanche C-Chain', rpc: 'https://api.avax.network/ext/bc/C/rpc', symbol: 'AVAX', explorer: 'https://snowtrace.io/tx/' },
      BASE:{ id: 'BASE', name: 'Base', rpc: 'https://mainnet.base.org', symbol: 'ETH', explorer: 'https://basescan.org/tx/' },
      SOL: { id: 'SOL', name: 'Solana', rpc: 'https://api.mainnet-beta.solana.com', symbol: 'SOL', explorer: 'https://explorer.solana.com/tx/' }
    };

    // ---------- DOM ----------
    const createBtn = document.getElementById('createBtn');
    const importMnemonicBtn = document.getElementById('importMnemonicBtn');
    const importKeyBtn = document.getElementById('importKeyBtn');
    const logoutBtn = document.getElementById('logoutBtn');
    const chainsDiv = document.getElementById('chains');
    const loadedDiv = document.getElementById('loaded');
    const receiveAddrDiv = document.getElementById('receiveAddr');
    const balanceDiv = document.getElementById('balance');
    const solHistoryDiv = document.getElementById('solHistory');
    const copyRecBtn = document.getElementById('copyRecBtn');
    const requestBtn = document.getElementById('requestBtn');
    const sendBtn = document.getElementById('sendBtn');
    const toInput = document.getElementById('toInput');
    const amountInput = document.getElementById('amountInput');
    const sendNotice = document.getElementById('sendNotice');
    const copyAddrBtn = document.getElementById('copyAddrBtn');
    const showMnemonicBtn = document.getElementById('showMnemonicBtn');
    const clearSendBtn = document.getElementById('clearSendBtn');

    // ---------- State ----------
    let selectedChain = 'ETH';
    // state stored in localStorage as 'vc_wallet'
    // structure: { mnemonic: string|null, evm: { address, privateKey } | null, sol: { address, secretBase64 } | null }
    let state = loadState();

    // ---------- Helpers ----------
    function saveState(s){ if(!s) localStorage.removeItem('vc_wallet'); else localStorage.setItem('vc_wallet', JSON.stringify(s)); }
    function loadState(){ try{ const s = localStorage.getItem('vc_wallet'); return s ? JSON.parse(s) : null }catch(e){return null} }
    function toBase64(u8){ return btoa(String.fromCharCode(...u8)); }
    function fromBase64(s){ const b = atob(s); const arr = new Uint8Array(b.length); for (let i=0;i<b.length;i++) arr[i]=b.charCodeAt(i); return arr; }
    async function copyToClipboard(text){ try{ await navigator.clipboard.writeText(text); alert('Copied'); }catch(e){ alert('Copy failed'); } }
    function setNotice(msg){ sendNotice.textContent = msg; setTimeout(()=>{ if(sendNotice.textContent===msg) sendNotice.textContent=''; }, 4000); }

    // ---------- Render chain buttons ----------
    function renderChainButtons(){
      chainsDiv.innerHTML = '';
      Object.values(CHAINS).forEach(c => {
        const btn = document.createElement('button');
        btn.textContent = c.id;
        btn.className = 'px-3 py-1 rounded bg-indigo-600';
        btn.dataset.chain = c.id;
        if (c.id === selectedChain) btn.classList.add('ring-2','ring-offset-1');
        btn.addEventListener('click', ()=>{ selectedChain = c.id; renderUI(); });
        chainsDiv.appendChild(btn);
      });
    }

    // ---------- UI render ----------
    async function renderUI(){
      renderChainButtons();

      if (!state) {
        loadedDiv.textContent = 'No wallet loaded';
        receiveAddrDiv.textContent = '—';
        balanceDiv.textContent = '—';
        solHistoryDiv.innerHTML = '';
        return;
      }

      const mn = state.mnemonic ?? '—';
      const evmAddr = state.evm?.address ?? '—';
      const solAddr = state.sol?.address ?? '—';
      loadedDiv.innerHTML = `Mnemonic: <span class="mono text-xs">${mn}</span><br/>EVM: <span class="mono">${evmAddr}</span><br/>SOL: <span class="mono">${solAddr}</span>`;

      // receive address based on selected chain
      receiveAddrDiv.textContent = selectedChain === 'SOL' ? solAddr : evmAddr;

      // update balances
      await updateBalance();

      // show sol history if SOL selected
      if (selectedChain === 'SOL') {
        await fetchSolHistory();
      } else {
        solHistoryDiv.innerHTML = '<div class="text-xs text-slate-400">Switch to SOL to view Solana history. EVM history requires an indexer API (Etherscan / Covalent / Alchemy).</div>';
      }
    }

    // ---------- Create / Import ----------
    createBtn.onclick = async ()=>{
      try {
        // create mnemonic using bip39 browser build
        const mnemonic = bip39.generateMnemonic();
        await createFromMnemonic(mnemonic);
        setNotice('Wallet created. Save your mnemonic securely.');
      } catch(err){
        console.error(err);
        alert('Create failed: ' + (err?.message || err));
      }
    };

    importMnemonicBtn.onclick = async ()=>{
      const m = prompt('Paste mnemonic (12/24 words)');
      if (!m) return;
      try {
        await createFromMnemonic(m.trim());
        setNotice('Mnemonic imported');
      } catch(err){ console.error(err); alert('Import failed: ' + (err?.message || err)); }
    };

    importKeyBtn.onclick = async ()=>{
      const k = prompt('Paste private key: EVM hex (0x...) or Solana base64 secretKey or comma-separated bytes');
      if (!k) return;
      try {
        if (selectedChain === 'SOL') {
          // support base64, hex, or comma-separated bytes
          let secret;
          if (k.includes(',')) {
            const arr = k.split(',').map(x => parseInt(x,10));
            secret = new Uint8Array(arr);
          } else {
            try { secret = fromBase64(k); } catch(e){
              // try hex
              const hex = k.replace(/^0x/,'');
              const bytes = new Uint8Array(hex.match(/.{1,2}/g).map(b => parseInt(b,16)));
              secret = bytes;
            }
          }
          const kp = solanaWeb3.Keypair.fromSecretKey(secret);
          state = { mnemonic: null, evm: state?.evm ?? null, sol: { address: kp.publicKey.toBase58(), secretBase64: toBase64(kp.secretKey) } };
          saveState(state);
          await renderUI();
          setNotice('Imported Solana private key');
        } else {
          // EVM import
          const w = new ethers.Wallet(k);
          state = { mnemonic: null, evm: { address: w.address, privateKey: w.privateKey }, sol: state?.sol ?? null };
          saveState(state);
          await renderUI();
          setNotice('Imported EVM private key');
        }
      } catch(err){ console.error(err); alert('Import key failed: ' + (err?.message || err)); }
    };

    logoutBtn.onclick = ()=> {
      if (!state) { alert('No wallet loaded'); return; }
      if (confirm('Clear wallet from browser? Make sure you have saved your mnemonic/private key.')) {
        state = null;
        saveState(null);
        renderUI();
        setNotice('Cleared wallet from browser storage');
      }
    };

    // ---------- Derive from mnemonic for both EVM & SOL ----------
    async function createFromMnemonic(mnemonic){
      // EVM: use ethers to derive first account
      // ethers v6 has Wallet.fromPhrase; helper fallback for older variations
      let evmWallet;
      try { evmWallet = ethers.Wallet.fromPhrase(mnemonic); } catch(e){
        try { evmWallet = ethers.Wallet.fromMnemonic(mnemonic); } catch(e2){ throw new Error('Ethers wallet derivation failed'); }
      }
      const evmAddress = evmWallet.address;
      const evmPrivateKey = evmWallet.privateKey;

      // Solana: seed derived via bip39 -> seed -> ed25519-hd-key derivePath
      const seedBuf = await bip39.mnemonicToSeed(mnemonic); // returns Buffer/Uint8Array
      // convert to hex for ed25519-hd-key
      const seedHex = Array.from(seedBuf).map(b => b.toString(16).padStart(2,'0')).join('');
      const derived = ed25519HdKey.derivePath("m/44'/501'/0'/0'", seedHex);
      const key = derived.key; // Uint8Array/Buffer (32)
      const kp = solanaWeb3.Keypair.fromSeed(new Uint8Array(key));
      const solSecretBase64 = toBase64(kp.secretKey);

      state = {
        mnemonic,
        evm: { address: evmAddress, privateKey: evmPrivateKey },
        sol: { address: kp.publicKey.toBase58(), secretBase64: solSecretBase64 }
      };
      saveState(state);
      await renderUI();
    }

    // ---------- Balance updates ----------
    async function updateBalance(){
      try {
        if (!state) { balanceDiv.textContent = '—'; return; }
        if (selectedChain === 'SOL') {
          if (!state.sol?.address) { balanceDiv.textContent = '—'; return; }
          const conn = new solanaWeb3.Connection(CHAINS.SOL.rpc, 'confirmed');
          const bal = await conn.getBalance(new solanaWeb3.PublicKey(state.sol.address));
          balanceDiv.textContent = (bal / solanaWeb3.LAMPORTS_PER_SOL) + ' SOL';
        } else {
          const rpc = CHAINS[selectedChain].rpc;
          const provider = new ethers.JsonRpcProvider(rpc);
          const addr = state.evm?.address ?? (state.mnemonic ? (ethers.Wallet.fromPhrase ? ethers.Wallet.fromPhrase(state.mnemonic).address : ethers.Wallet.fromMnemonic(state.mnemonic).address) : null);
          if (!addr) { balanceDiv.textContent = '—'; return; }
          const b = await provider.getBalance(addr);
          balanceDiv.textContent = ethers.formatEther(b) + ' ' + CHAINS[selectedChain].symbol;
        }
      } catch(err){ console.error('balance error', err); balanceDiv.textContent = 'error'; }
    }

    // ---------- Send functions ----------
    sendBtn.onclick = async ()=>{
      if (!state) return alert('No wallet loaded');
      const to = toInput.value.trim();
      const amount = amountInput.value.trim();
      if (!to || !amount) return alert('Enter recipient and amount');

      if (selectedChain === 'SOL') {
        await sendSol(state, to, amount);
      } else {
        await sendEvm(state, to, amount);
      }
    };

    async function sendEvm(state, to, amount){
      try {
        setNotice('Sending EVM transaction...');
        const rpc = CHAINS[selectedChain].rpc;
        const provider = new ethers.JsonRpcProvider(rpc);
        // get private key: prefer stored evm.pk, else derive from mnemonic
        let priv = state.evm?.privateKey;
        if (!priv && state.mnemonic) {
          const w = ethers.Wallet.fromPhrase ? ethers.Wallet.fromPhrase(state.mnemonic) : ethers.Wallet.fromMnemonic(state.mnemonic);
          priv = w.privateKey;
        }
        if (!priv) throw new Error('No EVM private key available (import or create with mnemonic).');
        const signer = new ethers.Wallet(priv, provider);
        const tx = await signer.sendTransaction({ to, value: ethers.parseEther(amount) });
        setNotice('Broadcasted: ' + tx.hash);
        // update balance after short delay
        setTimeout(()=>updateBalance(), 5000);
      } catch(err){ console.error('evm send', err); alert('EVM send failed: ' + (err?.message || err)); setNotice(''); }
    }

    async function sendSol(state, to, amount){
      try {
        setNotice('Sending SOL...');
        const conn = new solanaWeb3.Connection(CHAINS.SOL.rpc, 'confirmed');
        const secret = fromBase64(state.sol.secretBase64);
        const kp = solanaWeb3.Keypair.fromSecretKey(secret);
        const toPub = new solanaWeb3.PublicKey(to);
        const lamports = Math.round(parseFloat(amount) * solanaWeb3.LAMPORTS_PER_SOL);
        const tx = new solanaWeb3.Transaction().add(
          solanaWeb3.SystemProgram.transfer({
            fromPubkey: kp.publicKey,
            toPubkey: toPub,
            lamports,
          })
        );
        const sig = await solanaWeb3.sendAndConfirmTransaction(conn, tx, [kp]);
        setNotice('Solana tx: ' + sig);
        await updateBalance();
        await fetchSolHistory();
      } catch(err){ console.error('sol send', err); alert('Solana send failed: ' + (err?.message || err)); setNotice(''); }
    }

    // ---------- Solana history ----------
    async function fetchSolHistory(){
      try {
        solHistoryDiv.innerHTML = 'Loading...';
        if (!state?.sol?.address) { solHistoryDiv.innerHTML = '<div class="text-xs text-slate-400">No Solana address</div>'; return; }
        const conn = new solanaWeb3.Connection(CHAINS.SOL.rpc, 'confirmed');
        const sigs = await conn.getSignaturesForAddress(new solanaWeb3.PublicKey(state.sol.address), { limit: 12 });
        if (!sigs || !sigs.length) { solHistoryDiv.innerHTML = '<div class="text-xs text-slate-400">No recent txs</div>'; return; }
        const rows = [];
        for (const s of sigs) {
          const ptx = await conn.getParsedTransaction(s.signature);
          rows.push(`<div class="p-2 bg-white/6 rounded"><div>Sig: <a target="_blank" rel="noreferrer" href="${CHAINS.SOL.explorer + s.signature}" class="underline">${s.signature.substring(0,12)}...</a></div><div>Slot: ${s.slot}</div><div>Err: ${s.err ? JSON.stringify(s.err) : 'none'}</div></div>`);
        }
        solHistoryDiv.innerHTML = rows.join('');
      } catch(err){ console.error('fetch sol history', err); solHistoryDiv.innerHTML = '<div class="text-xs text-slate-400">History error</div>'; }
    }

    // ---------- Helpers used in flows ----------
    function fromBase64(s){ const bin = atob(s); const arr = new Uint8Array(bin.length); for (let i=0;i<bin.length;i++) arr[i]=bin.charCodeAt(i); return arr; }

    copyRecBtn.onclick = ()=> copyToClipboard(receiveAddrDiv.textContent || '');
    requestBtn.onclick = ()=> {
      // For Solana dev, one could request airdrop on devnet — but we're using mainnet RPC by default
      alert('Request action: For testing use dev networks or send from an exchange. Airdrop is not available on mainnet.');
    };
    copyAddrBtn.onclick = ()=> {
      if(!state) return alert('No wallet'); copyToClipboard(state.evm?.address ?? state.sol?.address ?? '');
    };
    showMnemonicBtn.onclick = ()=> {
      if(!state) return alert('No wallet'); alert('Mnemonic:\n' + (state.mnemonic ?? 'No mnemonic stored (imported private key only)'));
    };
    clearSendBtn.onclick = ()=> { toInput.value=''; amountInput.value=''; };

    // ---------- Init ----------
    (async ()=>{
      renderUI();
      // auto-refresh balances every 30s
      setInterval(()=> { if (document.visibilityState==='visible') updateBalance(); }, 30000);
    })();

    // ---------- EVM tx history note ----------
    // To show EVM history, register for Etherscan/BscScan/Covalent/Alchemy and call their account txlist endpoints:
    // Etherscan example: https://api.etherscan.io/api?module=account&action=txlist&address=ADDRESS&startblock=0&endblock=99999999&sort=desc&apikey=YOUR_KEY
    // Add code to call that API and show results in the UI.

  })();
  </script>
</body>
</html>
